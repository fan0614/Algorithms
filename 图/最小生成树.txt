加权图是一种为每条边关联的一个权值或是成本的图模型。

Q:最小生成树：给定一幅加权无向图，找到它的一棵最小生成树。
minimal spanning tree
图的生成树是它的一棵含有其所有顶点的无环连通子图。
一幅加权无向图的最小生成树(MST)是它的一棵权值(树中所有边的权值之和)最小生成树。

算法：Prim算法和Kruskal算法

约定：
1.只考虑连通图。非连通图，计算它的所有连通分量的最小生成树，合在一起称其为最小生成树森林。
2.边的权重不一定只表示距离。
3.边的权重可是会是0或者负数。
4.所有边的权重都各不相同。

原理：切分定理
图的一种切分是将图的所有顶点分为两个非空且不重复的两个集合。
横切边是一条连接两个属于不同集合的顶点的边。

切分定理：在一幅加权图中，给定任意的切分，它的横切边中权重最小者必然属于图的最小生成树。

贪心算法：
最小生成树贪心算法：反复利用切分定理，找到横切边，将权重最小的横切边标记为黑色，直到标记了V-1条黑色边为之。

加权无向图的数据类型：
EdgeWeightGraph{
int V;   //顶点总数
int E;    //边的总数
List<Edge>[] adj;  //邻接表
}
带权重的边的数据类型：
Edge{
int v;  //顶点之一
int w;   //另个顶点
double weight;   //边的权重
}

*******平行边和自环
和无环图的实现一样，这里也允许存在平行边。可以采用更复杂的方式消除平行边，只保留平行边中权重最小的边
允许存在自环。

最小生成树的API以及测试用例：
如何表示最小生成树：(图G的最小生成树是G的一幅子图并且同时也是一棵树)
1.一组边的列表
2.一幅加权无向图；
3.一个以顶点为索引且含有父节点链接的数组。

Pime算法
一棵树开始只有一个顶点，然后会向它添加V-1条边，每次总是将下一条边连接树中的顶点与不在树中的顶点且权重最小的边加入树中。

数据结构：
表示树中的顶点，边和横切边。
1.顶点。使用一个由顶点索引的布尔数组marked[] 如果顶点v在树中，那么marked[v]的值为true。
2.边。
方式1：一条队列mst来保存最小生成树中的边
方式2：一个顶点索引的Edge对象的数组edgeTo[],其中edgeTo[v]为将v连接到树中的Edge对象。
3.横切边。
使用一条优先队列MinPQ<Edge>来根据权重比较所有边。

一种延时实现，即在优先队列中保存失效的边。
一种即时的实现，尝试删除优先队列里失效的边，这样优先队列里只含有树顶点和非树顶点的之间的横切边。
可以删除更多的边，简言之，我们不需要在优先队列里保存所有从w到树顶点的边(w为非树顶点)――而只需要保存其中权重最小的那条。

即时实现的数据结构：
用edgeTo[] 和 distTo[]  
1.如果顶点v不在树中但至少含有一条边和树相连，那么edgeTo[v]是将v和树连接的最短边，distTo[v]为这条边的权重。
2.所有的这类顶点v都保存在一条索引优先队列中，索引v关联的值是edgeTo[v]的边的权重。

*************Kruskal算法*************
按照边的权重顺序处理，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。

Prim算法是一条边一条边地来构造最小生成树，每一步都为一棵树添加一条边。Kruskal算法构造最小生成树地时候也是一条边一条边的构造。但是不同的是它寻找的边会连接一片森林中的两棵树。

有向图的最小生成树问题：最小树形图问题。




















