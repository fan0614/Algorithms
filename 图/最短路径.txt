Q：找到从一个顶点到达另一个顶点的成本最小的路径。
定义：在一份加权无向图中，从顶点s到达顶点t的最短路径是所有从s到t的路径中的权重最小者。

单点最短路径。
给定一幅加权有向图和一个起点s，Q：从s到给定的目的顶点v是否存在一条有向路径。如果有，找出最短（总权重最小）的那条路径。

最短路径的性质：
1.路径是有向的。最短路径需要考虑到各条边的方向。
2.权重不一定等于距离。双关性术语：权重或者成本最短的路径。
3.并不是所有的顶点都是可达的。
4.最短路径一般都是简单的。
5.最短路径不一定是唯一的。
6.可能存在平行边和自环。

最短路径树：单点路径问题。
给出起点s，计算结果是一颗最短路径树(SPT),它包含了顶点s到达所有可达的顶点的最短路径。

定义：给定一幅加权有向图和一个顶点s，以s为起点的一棵树最短路径是图的一幅子图，它包含s和从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。

*******加权有向图的数据结构
加权有向图的数据结构比加权无向图的数据结构更加简单，因为有向边只有一个方向。

最短路径的API：

最短路径的数据结构：
最短路径树中的边。使用一个顶点索引的DirectedEdge对象的父链接数组edgeTo[]。

到达顶点的距离。我们需要一个由顶点索引的数组distTo[],其中distTo[V] 为从s 到 v的已知最短路径的长度。

并且约定 edge[s]的值为null，distTo[s] 的值为0.不可达的距离为Double.POSITIVE_INFINITY

***边的松弛（relaxation）
定义：放松边v - >w 意味着检查从s到w的最短路径是否是先从s到v，然后再由v到w。
private void relax(DirectedEdge e){
	int v = e.from(), w=e.to();
	if(distTo[w] > distTo[v]+e.weight()){
		distTo[w] = distTo[v] + e.weight();
		edgeTo[w] = e;
	}
}
***顶点的松弛
private void relax(EdgeWeightedDigraph G,int v){
	for(DirectedEdge e : G.adj(v)){
		int w = e.to();
		if(distTo[w]>distTo[v]+e.weight()){
			distTo[w] = distTo[v]+e.weight();
			edgeTo[w] = e;
		}
	}
}
***最短路径算法的理论基础
最优性条件：判断路径是否为最短路径的全局条件与在放松一条边时所检测的局部条件时等价的。
最短路径的最优性条件：
         令G为一幅加权有向图，顶点s是G中的起点，distTo[ ] 是一个由顶点索引的数组，保存的是G中路径的长度。对于从s可达的所有顶点v，distTo[v]的值是从s到v的某条路径的长度，对于从s不可达的所有顶点v，该值为无穷大。当且仅当对于从v到w的任意一条边e，这些值都是满足distTo[w]<=distTo[v] + e.weight()，它们时最短路径的长度。

通用最短路径的算法：
将distTo[s] 初始化为0，其他distTo[ ]元素初始化无穷大，继续如下的操作：
	放松G中的任意边，直到不存在有效边为之。
对于任意从s可达的顶点w，在进行这些操作之后，distTo[w]的值即为从s到w的最短路径的长度(且edgeTo[w]的值即为该路径上的最后一条边)

通用算法并没有指定边的放松顺序。

**************Dijkstra算法
Dijkstra算法能解决边权重非负的加权有向图的单起点的最短路径问题。

Dijkstra算法的实现每次都会为最短路径树添加一条边，该边由一个树中的顶点指向一个非树顶点w且它是到s最近的顶点。

Q:给定两点的最短路径：给定一幅加权有向图以及一个起点s和一个终点t，找到从s到t的最短路径。
A：Dijkstra算法从优先队列取到t后终止搜索。

Q:任意两个顶点之间的最短路径。
给定一幅加权有向图，回答“给定一个起点s和一个终点t，是否存在从s到t的路径”？如果有，找出最短（权重最小）的那条路径。

欧拉图中的最短路径：在顶点为平面上的点且边的权重与顶点欧拉间距成正比的图中。解决单点、给定两点和任意顶点对之间的最短路径问题。

*********加权无环图的最短路径
无环加权有向图中的最短路径算法
特点：
1.能够在线性时间内解决单点最短路径问题；
2.能够处理负权重的边；
3.能够解决相关问题，例如找出最长路径。
上述都是无环有向图的拓扑排序的算法的简单扩展。

无环加权有向图中的最短路径问题：顶点的放松 + 拓扑排序

首先，将distTo[s]初始化为0，其他distTo[]元素初始化为无穷大，然后一个一个地按照拓扑顺序放松所有顶点。

命题： 按照拓扑顺序放松顶点，就能在和E+V成正比的时间内解决无环加权有向图的单点最短路径问题。

对于最短路问题，基于拓扑排序的方法比Dijksta算法快的倍数与Dijkstra算法中的所有优先队列操作的总成本成正比。
命题的证明和边的权重是否非负无关，因此无环加权有向图不会受到任何限制。

****************最长路径
考虑在无环加权有向图中寻找最长路径的问题，边的权重可正可负。
无环加权有向图中的单点最长路径。给定一幅无环加权有向图(边的权重可能为负) 和一个起点s，回答“是否存在一条从s到给定的顶点v的路径？”如果有，找出最长（总权重最大）的那条路径。等类似问题。

命题：解决无环加权有向图中的最长路径问题所需的时间与E+V成正比。

***********************平行任务调度******************
优先级限制下的并行任务调度：
给定一组需要完成的特定任务，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何在若干相同的处理器上(数量不限)安排任务并在最短的时间内完成所有任务。

*****”关键路径“的方法可以证明这个问题与无环加权有向图中的最长路径问题等价。

****解决并行任务调度问题的关键路径方法步骤：
1.创建一幅无环加权有向图，其中包含一个起点s和一个终点t且每个任务对应着两个顶点(一个起始顶点和一个结束顶点)。对于每个任务都有一个起始顶点指向结束顶点的边。
2.边的权重为任务所需的时间。对于每条优先级限制v->w,添加一条从v的结束顶点指向w的起始顶点的权重为零的边。
3.为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。

各条最长路径的长度，也就正好是每个任务的开始时间。

命题：解决优先级限制下的并行任务调度问题的关键路径法所需的时间为线性级别。

相对最后期限限制下的并行任务调度：
一般的最后期限(deadline)都是相对于第一个任务的开始时间而言的。

命题：相对最后期限限制下的并行任务调度问题（可能存在环和负权重边）















