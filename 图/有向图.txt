有向图的可达性和无向图的连通性。

有向图的数据结构：使用邻接表。且比无向图更加明晰，因为每条边都只会出现一次。

有向图取反(reverse()方法)：将其中所有的边的方向反转。
作用：找出“指向”每个顶点的所有边，而adj()给出的是由每个顶点指出的边所连接的所有顶点。

有向图中的可达性：
单点可达性给定一幅有向图和一个起点s，回答“是否存在一条从s到达给定顶点v的有向路径”

***************************************************标记-清除的垃圾收集****************************************************
多点可达性：典型的内存管理系统中

在一幅有向图中，一个顶点表示一个对象，一条边则表示一个对象对另一个对象的引用。
**************************************************有向图的寻路************************************************************
单点有向路径

单点最短有向路径

************************************************环和有向无环图*********************************************************

************************************************调度问题***************************************************************
优先级限制的调度问题：给定一组需要完成的任务，以及一组关于任务完成得先后次序得优先级限制。在满足限制条件的前提下应该如何安排并完成所有任务?

拓扑排序：给定有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素(或者说明无法做到这一点)

***************************************************有向图的环*************************************************************
如果一个优先级限制的问题中存在有向环，那么这个问题肯定是无解的。
有向环的检测：给定的图中包含有向环吗？如果有，按照路径的方向从某个顶点并返回自己来找到环上的所有顶点。

有向无环图(DAG) :一幅不含环的有向图     Directed Acyclic Graph(DAG)
顶点的深度优先次序与拓扑排序：

当前仅当一幅有向图是无环图时它才能进行拓扑排序。

”有向图中基于深度优先搜索的顶点排序“ 基本思想：深度优先搜索正好只会访问每个顶点一次，如果将dfs()的参数顶点保存在一个数据结构中，遍历这个数据结构就能访问图中的所有顶点一次，遍历的顺序取决于这个数据结构的性质以及在递归调用之前还是之后进行保存。


3种顶点的排列顺序：
前序：在递归调用之前将顶点加入队列。pre()
后序：在递归调用之后将顶点加入队列。post()
逆后序：在递归调用之后将顶点压入栈。reversePost()

******一幅有向无环图的拓扑排序即为所有顶点的逆后序排列。

解决任务调度类的应用（3步）：
1.指明任务和优先级条件；
2.不断检测并去除有向图中的所有环，以确保存在可行方案的；
3.使用拓扑排序解决调度问题

*****************************************************有向图中的强连通性***************************************************
强连通：如果两个顶点v和w是互相可达的。
有向图强连通：如果一幅有向图中的任意两个顶点都是强连通的，则称这幅图也是强连通的。

*****两个顶点强连通  <<==>> 他们都在一个普通的有向环中

强连通分量：
自反性：任意顶点v和自己都是强连通的。
对称性：如果v和w是强连通的，那么w和v也是强连通的
传递性：如果v和w是强连通的且w和x也是强连通的，那么v和x也是强连通的。

根据等价关系划分等价类，每个等价类都是由相互均为强连通的顶点的最大子集组成的。这些子集称为强连通分量。

注意：强连通分量是基于顶点而不是基于边。

********Kosaraju算法
在给定的一幅有向图G中，使用DepthFirstOrder来计算它的反向图GR的逆后序排列。
在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有未被标记的顶点。
在构造函数中，所有在同一个递归dfs()调用中被访问到的顶点都在同一个强连通分量中，将它们按照和CC相同的方式识别出来。

1.证明：每个和s强连通的顶点v都会在构造函数调用的dfs(G,s)中被访问到。
反证法。
2.证明：构造函数调用的dfs(G,s)所到达的任意顶点v都必然是和s强连通的。
需要证明G中存在一条从v 到 s 的路径 <<==>>GR 中存在一条从s到v的路径
证明的核心：
按照逆后序进行深度优先搜索，dfs(G,v)必然在dfs(G,s)之前就结束了。
调用dfs(G,v)两种情况：
调用在dfs(G,s)的调用之前(并且也在dfs(G,s)的调用之前结束)；
调用在dfs(G,s)的调用之后(并且也在dfs(G,s)的调用之前结束)。

*****************************************************再谈可达性************************************
顶点对的可达性：
给定一幅有向图，是否存在一条从一个给定的顶点v到另一个给定顶点w的路径？

对于无向图，上述问题等价于连通性问题。
对于有向图，不同于强连通问题。

有向图G的传递闭包是由相同的一组顶点组成的另一幅有向图，在传递闭包中存在一条从v指向w的边当且仅当G中w是从v可达的。





















