散列函数：将键转为数组的索引。易于计算并且能够均匀分布所有的键。
处理碰撞冲突：拉链法和线性探测法

*散列函数
对于每种类型的键 我们都需要一个与之对应的散列函数。

hash方法：
正整数：除留余数法。 选择大小为素数M的数组。
#如果M非素数，无法利用键中的所有信息，不能均匀分布键

浮点数：
方法一//有缺陷；键的高位起的作用更大
键是0-1的实数；乘以M然后四舍五入
方法二
转为二进制然后除留余数法法

字符串：
除留取余法

组合键：类似字符串
Date:
int hash = (((day*R+month)%M)*R+year)%M

java的约定：一致性  每一种数据类型的hashCode()方法都必须和equals()方法返回一致

java重写了hashCode()方法（String、Integer、Double、File、URL）

************************************************************
软缓存：String类型缓存在了hash这个变量里

优秀散列算法的三个条件：
一致性――等价的键必须产生相等的散列值
高效性――计算简便
均匀性――均匀地散列所有的键

****************************************************
基于拉链法的散列表：
将大小为M的数组中的每个元素指向一个链表。
查找分为两步：根据散列值找到对应的链表，然后沿着链表顺序查找响应的键

缺点：不适合快速找到最大或者最小的键，或者查找某个范围内的键

*******************************************************
基于线性探测法的散列表：
用大小为M的数组保存N个键值对。其中M>N。
依靠数组中的空位解决碰撞冲突。
统称为开放地址散列表。

alpha = N/M
alpha 称为 散列表的使用率。需要保证使用率在1/8到1/2之间

键簇























