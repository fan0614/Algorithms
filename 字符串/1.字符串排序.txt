两类完全不同的字符串排序方法：
1.从右到左检查键中的字符（LSD）低位优先的字符串排序。
2.从左到右检查键中的字符（MSD）高位优先的字符串排序。

*************************************键索引计数法******************************************************
适用于小整数键的简单排序方法
1.频率统计   int类型数组count[]计算每个键出现的频率
2.将频率转化为索引    使用count[] 来计算每个键在排序结果中的起始索引位置。
3.数据分类  
4.回写
命题：键索引计数法排序的N个键为0到R-1之间的整数的元素需要访问数组11N + 4R +1次。
所有的移动操作都维护了等键元素的相对顺序。

键索引计数法不需要比较（它只通过key()方法访问数据） 只要当R在N的一个常数因子范围内，它都是一个线性时间级别的排序方法。

*****************************************低位优先的字符串排序*****************************************
（LSD） Least Significant Digit first（最低位优先）
适用于键的长度都相同的字符串排序应用。

低位优先的字符串排序算法能够稳定地将定长字符串排序。

命题：对于基于R个字符的字母表的N个以长为W的字符串为键的元素，低位优先的字符串排序需要访问~7WN+3WR次数组，使用的额外空间与N+R成正比。

****************************************高位优先的字符串排序*****************************************
（MSD）(Most Significant Digit first)  最高位优先
专门处理变长键排序的算法
要实现一个通用字符串排序算法(字符串的长度不一定相同)，应该考虑从右到左遍历所有字符。
递归的思想：
首先用键索引计数法将所有的字符串按照首字母排序，然后再将每个首字母所对应的子数组排序（忽略首字母，因为每一类中的所有字符串的首字母都是相同的）。

对字符串末尾的约定：

指定的字母表：

小型子数组：
MSD是有效的：在一般的应用中，只需要检查若干个字符就能完成所有字符串的排序。
换句话说，这种方法能够快速的将需要排序的数组切分成较小的数组。

***小型子数组对于高位优先的字符串排序的性能至关重要。
故而将小数组切换到插入排序对于高位优先的字符串排序算法是必须的。

***等值键
高位优先的字符串排序中的第二个陷阱是，对于含有大量等值键的子数组的排序会较慢。

额外空间：
为了进行切分，高位优先的算法使用了两个辅助数组：
1.用来将数据分类的临时数组(aux[])
2.一个用来保存将会被转化为切分索引的统计频率数组（count[ ]）

****随机字符串模型（研究高位优先的字符串排序算法的性能）

****性能

*************************************三向字符串快速排序******************************
改进高位优先的字符串排序算法，根据键的首字母进行三向切分，仅在中间子数组中的下一个字符继续递归排序。

三向字符串快速排序只将数组切分为三部分，。
三向切分可以很好的处理等键值、有较长公共前缀的键、取值范围较小的键和小数组――所有高位优先的字符串排序算法不擅长的各种情况。
三向切分快速排序也不需要额外的空间(递归所需的隐式栈除外)，相比于高位优先的字符串排序的一大优点。
后者在统计频率和使用辅助数组时都需要额外空间。

小型子数组
有限的字母表

字符串排序算法的选择：





























